# Aporte de los mensajes de DD
En cada llamado, el objeto contestará distinto según la clase a la que pertenezca. Entonces, cada llamado aportará el "tipo" del objeto. Por ejemplo, en el trabajo **Numeros-Parte2**, para quitar los ifs de el mensaje de clase `with:over:` de `Fraccion`, utilizamos polimorfismo doble, ya que llamamos primero al divisor  (con el mensaje `fraccionandoA:`) para responder según valiera `0`, `1`, negativo o mayor a uno. Luego, llamamos a el dividendo (con el mensaje `sobre:`) para responder según fuera `0` o negativo/positivo. 
# Lógica de instanciado
Para facilitar la creación de instancias en la clase correcta, es conveniente que la lógica del instanciado corresponda a la subclase concreta (que no tiene subclases propias). Si el objeto se instanciara de una clase abstracta, podría generar errores no sabiendo responder a mensajes que corresponden a las subclases. Esto se suele explicitar con el error `self subclassResponsability`.
Para poder delegar esta responsabilidad en la subclase correspondiente cuando se le pide a una clase abstracta que genere una instancia, podemos utilizar un iterador que recorra las subclases. Para esto, cada subclase debe poder contestar a un mensaje que responda si el valor es aceptado por la misma. Utilizamos `self subclasses` para obtener la colección de subclases correspondiente e iteramos hasta encontrar una que nos responda `true` a dicho mensaje. Por ejemplo, para el trabajo práctico necesitábamos instanciar enteros de distintas subclases (positivos, negativos, ceros). Para esto, implementamos el método `aceptaEsteValor:` que responde `true` si el valor del colaborador está dentro del rango aceptado.
# Nombres de las categorías de métodos
Nombramos las categorías según su función, excepto por la categoría "privado" que sólo es de uso interno del objeto. Esto se refiere a que sus mensajes sólo deberían ser enviados dentro de la implementación de otros métodos del mismo objeto, y no desde afuera. Además, agregamos las letras `DP` para señalizar que esta categoría contiene mensajes que se utilizan en una aplicación de Doble Polimorfismo.
# Subclass Responsibility
Corresponde implementar un método, a pesar de que esté ya implementado en todas las subclases, para indicar el conjunto de mensajes que responde la clase (lo que caracteriza su polimorfismo). `self subclassresponsability` tiene dos funciones. La primera es la descripta anteriormente; explicitar que este método ya está implementado en todas las subclases y estas responderán de distinta manera. La segunda es emitir un mensaje de error en caso de que se envíe este mensaje a la clase abstracta.
# No rompas
Al romper encapsulamiento estamos asignando incorrectamente las responsabilidades de los objetos. Esto puede traer muchos problemas a la hora de debuggeear nuestro programa, ya que la falla de un objeto podría corresponder a otro que no debería.
Esto es una manifestación de un mal modelado de nuestro dominio, ya que estaríamos representando incorrectamente la forma en que las entidades interactúan entre sí.